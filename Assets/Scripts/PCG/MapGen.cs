using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.IO;

using UnityEngine.UI;

public class MapGen : MonoBehaviour {

	public int width; //width of the generated map
	public int height; //height of the generated map

	public GameObject playerSpawn;// Player Spawn location, may be better with transform for location
	public GameObject player;
	public GameObject endPoint; // End Point location as oppose to player spawn location for level ending and generation of new one

	public float levelFinished; //Counter for number of levels finished
	public bool levelComplete; // Once completed a new level will be generated
	public bool gameOver; // Will be called true when suffcient amount of levels have been completed and test is over, data will be exported to be written to file 

	public string seed; //Random seed generated by system
	public static string seedRec;
	public bool useRandomSeed; //Use or not use the randomseed

	[Range(0,100)] //can only be 1 to 100
	public int randomFillPercent;

	int[,] map; //2D array of ints

	public MeshGen meshGenerator; //Mesh Generator class

	//public Vector3 spawnValues;
	public Vector2 mapSize;

	Coord mapEdge; //Coordinates for the map edge
	Coord mapEdgeExit; // Duplicate coordinates
	Coord mapCentre;

	Transform[,] tileMap; //2D array for tracking the tile map

	public static bool explorer; //explorer Taxonomy
	public static bool killer; //Killer Taxonomy
	public static bool acheiver; //Acheiver Taxonomy
	public bool isExplorer; //For calculating explorer type
	public bool isKiller; //For calculating killer type
	public bool isAcheiver; //For calculating acheiver type

	public Transform targetPrefab; //transform type for targets
	public GameObject playerSpawnPoint;

	List<Coord>allTileCoords; // List of all tile coordinates

	Queue<Coord> shuffledTileCoords; // Queue type for shuffling coords from the Utility script
	Queue<Coord> shuffledRandomTileCoords;

	//Queue<Coord> shuffledOpenTileCoords;
	//public List<Coord>openTileCoords;

	public List<Coord> wallEdgeTiles;

	 public int seedx = 10; //secondary seed

	public static int endLevelValue;

	public static int Explored; //tracking the amount of map explored
	public static int Accurate; //tracking the amount of enemies hit on target
	public static int defeated; //amount of enemies defeated
	public static float timeSaved; //timestamp of time taken
	public static int totalEnemies; //Total number of enemies that were alive
	public static int levelNumber;

	public int levelTrack;

	public int exploreValue; 
	public int accurateValue;
	public int numberEnemies; 
	public GameObject[] enemies; //Array of enemies to track targets

	GameObject endPointCheck;
	GameObject spawnerCheck;

	public int fileValue;

	public  bool isComplete;
	public float TimeInSeconds; // float for time 

	public dataScript saveData; //reference to the script for collecting and exporting test data

	public float distance;

	void Start() {
		GenerateMap(); //Method calling the generator
		Explored = 0;
		TimeInSeconds = 0; 
		isExplorer = false;
		isKiller = false;
		isAcheiver = false;
		levelNumber = 0;
		levelTrack = 0;
		isComplete = false;
		fileValue = 0;

	}

	public void complete()
	{
		isComplete = true;
		if (fileValue == 0) {
			saveData.save ();
		}

		if (fileValue == 1) {
			saveData.save2 ();
		}
		if (fileValue == 2) {
			saveData.save3 ();
			changeScene(2);
		}
		if (fileValue == 3) {
			
			changeScene(2);
		}
	}

	void checkFiles()
	{
		if (System.IO.File.Exists ("Data.txt")) 
		{
			//Debug.Log ("File already exists");
			fileValue = 1;
		}
		if (System.IO.File.Exists ("Data2.txt")) 
		{
			//Debug.Log ("File already exists");
			fileValue = 2;
		}
		if (System.IO.File.Exists ("Data3.txt")) 
		{
			//Debug.Log ("All Files detected");
			fileValue = 3;
			changeScene (2);
		}
	}

	void Update() {
		
		decideTax();
		checkFiles ();
		checkDistance ();

		//checkSpawner ();
		/*foreach (Coord x in openTileCoords) 
		{
			Debug.Log (x);
		}*/

		//distance = Vector3.Distance (endPoint.transform.position, playerSpawn.transform.position);

		/*if (distance < 80) {
			Coord randomCoord = GetRandomCoord ();
			Vector3 newPosition = CoordToPosition (randomCoord.tileX, randomCoord.tileY);
			endPoint.transform.position = newPosition;
			Debug.Log ("Too close");
			//Destroy (playerSpawn);
			//Destroy (endPoint);
			//respawnExit ();
			//respawnSpawn ();

		}*/

		/*if (Input.GetKey ("space")) {
			GenerateMap(); //use mouse click to generate new map with each click
			meshGenerator.removeWallMesh();
			clearTargets ();
			clearSpawner ();
			//levelTrack = levelTrack + 1;

			//Destroy old mesh and walls and make new mesh 
		}*/
	//.................................. OVERRIDE KEYS
		/*if (Input.GetKey ("left")) {
			saveData.save ();
		}
		if (Input.GetKey ("up")) {
			saveData.save2 ();
		}
		if (Input.GetKey ("right")) {
			saveData.save3 ();
		}

		if (Input.GetKey ("o")) {
			overideSpawn ();
		}
			*/
	//..................................

		if (Input.GetKey ("escape")) 
		{
			Application.Quit ();
		}
		levelTrack = endLevelValue;
		levelNumber = levelTrack;

		enemies = GameObject.FindGameObjectsWithTag ("Enemy");
		playerSpawn = GameObject.FindGameObjectWithTag ("Spawn");

		for (int i = 0; i < enemies.Length; i++)
		{
			numberEnemies = i;
			totalEnemies = numberEnemies;
		}	

		TimeInSeconds += 1*Time.deltaTime;

		exploreValue = Explored;
		accurateValue = Accurate;
		timeSaved = TimeInSeconds;

		explorer = isExplorer;
		killer = isKiller;
		acheiver = isAcheiver;
		seedRec = seed;
	}

	void overideSpawn()
	{
	meshGenerator.removeWallMesh();
	clearTargets ();
	clearSpawner ();
	levelComplete = false;
		GenerateMap(); //use mouse click to generate new map with each click
		
		//clearPlayer ();
		//StartCoroutine (Dead ());
		
	}
	public void regenLevel()
	{
	meshGenerator.removeWallMesh();
	clearTargets ();
	clearSpawner ();
	clearValues ();
		GenerateMap(); //use mouse click to generate new map with each click
		
		Debug.Log("RESET COMPLETE");

	}
	void clearSpawner()
	{
		Destroy (playerSpawn);
		//Destroy (endPoint);
	}

	void checkDistance()
	{
		GameObject endPointCheck;
		GameObject spawnerCheck;

	endPointCheck = GameObject.FindGameObjectWithTag ("EndPoint");
	spawnerCheck = GameObject.FindGameObjectWithTag ("Spawn");

//	distance = Vector3.Distance (endPoint.transform.position, playerSpawn.transform.position);
	distance = Vector3.Distance (GameObject.FindGameObjectWithTag("EndPoint").transform.position, GameObject.FindGameObjectWithTag("Spawn").transform.position);

		if (distance <= 120) 
		{
			Debug.Log ("Too Close");

		Coord randomNewCoord = GetRandomCoord ();
		Vector3 spawnNewPosition = CoordToPosition (randomNewCoord.tileX, randomNewCoord.tileY);
		//DestroyImmediate (endPoint,true);
			//respawnExit ();
		GameObject.FindGameObjectWithTag("EndPoint").transform.position = spawnNewPosition;


	}
	}

	void clearTargets()
	{
		foreach (GameObject x in enemies)
		{
			Destroy (x);
		}

	}

	public void changeScene( int sceneToChangeTo )
	{
		Application.LoadLevel (sceneToChangeTo);
	}

	public void respawnSpawn()
	{
		Coord randomCoord = GetRandomCoord ();
		Vector3 spawnPosition = CoordToPosition (randomCoord.tileX, randomCoord.tileY);
	GameObject spawnPoint = Instantiate (playerSpawn, spawnPosition + Vector3.up, Quaternion.Euler(0,0,90)) as GameObject;
	}

	public void respawnExit()
	{
		Coord randomCoord = GetRandomCoord ();
		Vector3 spawnPosition = CoordToPosition (randomCoord.tileX, randomCoord.tileY);
		//Transform spawnPoint = Instantiate (endPoint, spawnPosition + Vector3.up, Quaternion.Euler(0,0,90)) as Transform;
		GameObject exitPoint = Instantiate (endPoint, spawnPosition + Vector3.up * 0.5f, Quaternion.Euler (270, 0, 90)) as GameObject; //real one
		
	}

	void clearValues()
	{
		Explored = 0;
		Accurate = 0;
		defeated = 0;
		timeSaved = 0;
		totalEnemies = 0;
		TimeInSeconds = 0;
		endPointCheck = null;
		spawnerCheck = null;

	}
	void checkSpawner()
	{/*
		if (player = null) {
			respawnSpawn ();
		}	*/
	}
	void decideTax()
	{
		if (exploreValue >= 150 && accurateValue < 25) 
		{
			isExplorer = true;
		}
		else
		{
			isExplorer = false;	
		}

		if (accurateValue > 35) 
		{
			isKiller = true;
		}
		else
		{
			isKiller = false;	
		}

		if (TimeInSeconds <= 120 && accurateValue < 20) 
		{
			isAcheiver = true;
		}
		else
		{
			isAcheiver = false;	
		}
	}
		
void spawner ()
	{
		//List<Room> roomListA = new List<Room> ();
		//List<Room> roomListB = new List<Room> ();

		System.Random pseudoRandom = new System.Random(seedx.GetHashCode()); //random number generator
		//openTileCoords = new List<Coord>();
		allTileCoords = new List<Coord> ();

		for (int x = 0; x < mapSize.x; x++) {
			for (int y = 0; y < mapSize.y; y++) {
				allTileCoords.Add (new Coord (x, y));
			}
		}
		/*foreach (Coord tile in allTileCoords) {
			Debug.Log ("test");
		}*/
		//wallEdgeTiles = Room.openTileCoords;

		shuffledTileCoords = new Queue<Coord> (Utility.ShuffleArray (allTileCoords.ToArray (), seedx));
		//shuffledRandomTileCoords = new Queue<Coord> (Utility.ShuffleArray (openTileCoords.ToArray (), seedx));
		/*for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				map [x, y] == 1 ? isWall = true: isWall = false; 
			}
		}*/

	
	/*List<List<Coord>> roomRegions = GetRegions (0);

		foreach (List<Coord> roomRegion in roomRegions) { //info gathered from Rooms
			//if (roomRegion.Count < roomThresholdSize) {
			foreach (Coord tile in roomRegion) {
				//Instantiate (playerSpawn, Vector3.right, Quaternion.identity) as Transform;
				//map [tile.tileX, tile.tileY] = 1;
				//Debug.Log("");
				openTileCoords.Add(new Coord (tile.tileX,tile.tileY));
			}
		}*/

		/*for (int x = 0; x < mapSize.x; x++) {
			for (int y = 0; y < mapSize.y; y++) {

				//int spawnPoints = 1;
				//for (int i = 0; i < spawnPoints; i++) {
					Vector3 tilePosition = CoordToPosition (x, y);
					Transform spawnPoint = Instantiate (spawnPrefab, tilePosition, Quaternion.identity)as Transform;
				//}
			}
		}*/

	//Targets
		int spawnPoints = 70;

		if (isKiller = true) 
		{
			spawnPoints = spawnPoints + 10;
		}
		for (int i = 0; i < spawnPoints; i++) {
	
			Coord randomCoord = GetRandomCoord ();
			Vector3 spawnPosition = CoordToPosition (randomCoord.tileX, randomCoord.tileY);

		//Coord randomTileCoord = GetRandomTileCoord();
			//Vector3 spawnPosition = CoordToPosition (randomTileCoord.tileX, randomTileCoord.tileY);

		Transform spawnPoint = Instantiate (targetPrefab, spawnPosition + Vector3.up, Quaternion.Euler(0,0,90)) as Transform;
		}
	//Player Start 	
			//mapEdge = new Coord (width /2 + 5 , height / + 5);

			Coord randomSpawnCoord = GetRandomCoord ();
			Coord randomExitCoord = GetRandomCoord ();

			Vector3 randomSpawn = CoordToPosition (randomSpawnCoord.tileX, randomSpawnCoord.tileY);
			Vector3 randomExitSpawn = CoordToPosition (randomExitCoord.tileX, randomExitCoord.tileY);

			

			//mapEdge = new Coord (width - 10, height - 190);
			//Vector3 edgeSpawn = CoordToPosition (mapEdge.tileX, mapEdge.tileY);
			GameObject spawner = Instantiate (playerSpawn, randomSpawn + Vector3.up * 0.5f, Quaternion.identity) as GameObject;

			//End Point
			//mapEdgeExit = new Coord (width - 140, height - 10);
			//mapEdgeExit = new Coord (width/2 + 10, height/2 + 10);
			//Vector3 edgeSpawnExit = CoordToPosition (mapEdgeExit.tileX, mapEdgeExit.tileY);
			GameObject exitPoint = Instantiate (endPoint, randomExitSpawn + Vector3.up * 0.5f, Quaternion.Euler (270, 0, 90)) as GameObject;

			//Player
			//mapCentre = new Coord (width / 2, height / 2);
			//mapCentre = new Coord (width - 10, height - 190);
			//Vector3 centreSpawn = CoordToPosition (mapCentre.tileX, mapCentre.tileY);
		GameObject Player = Instantiate (player, playerSpawn.transform.position + Vector3.up * 1.0f, Quaternion.identity) as GameObject;
	}

	public Coord GetRandomCoord() {

		Coord randomCoord = shuffledTileCoords.Dequeue ();

		shuffledTileCoords.Enqueue (randomCoord);

		return randomCoord;
	}

	public Coord GetRandomTileCoord()
	{
		Coord randomTileCoord = shuffledRandomTileCoords.Dequeue ();
		shuffledRandomTileCoords.Enqueue (randomTileCoord);
		return randomTileCoord;
	}



	void GenerateMap() {			//method for generating map
	
		map = new int[width,height];
		
		/*mapEdge = new Coord (width / 2, height / 2);
		Vector3 centreSpawn = CoordToPosition (mapEdge.tileX, mapEdge.tileY);
		Transform spawner = Instantiate (spawnPrefab, centreSpawn + Vector3.up * 0.5f, Quaternion.identity) as Transform;*/
	
		RandomFillMap();

		for (int i = 0; i < 5; i ++) { //increments of smooth map
			SmoothMap();
		}

		ProcessMap (); //checks tile regions for small isolated islands of walls 

		int borderSize = 2; // size of the border around generated map
		int[,] borderedMap = new int[width + borderSize * 2,height + borderSize * 2]; // 2d int array for the border of the map for both sides (L+R)

		for (int x = 0; x < borderedMap.GetLength(0); x ++) { //make bordered map same size but only slightly larger
			for (int y = 0; y < borderedMap.GetLength(1); y ++) {
				if (x >= borderSize && x < width + borderSize && y >= borderSize && y < height + borderSize) { //&& and // 
					borderedMap[x,y] = map[x-borderSize,y-borderSize];// set bordered map
				}
				else {
					borderedMap[x,y] =1; //if inside bordered map
				}
			}
		}

		MeshGen meshGen = GetComponent<MeshGen>(); //Generate mesh from Mesh Gen
		meshGen.GenerateMesh(borderedMap, 1);

	spawner ();

	endPointCheck = GameObject.FindGameObjectWithTag ("EndPoint");
	spawnerCheck = GameObject.FindGameObjectWithTag ("Spawn");
	}

	void ProcessMap() { //getting list of list of Coord of wall regions. 
		List<List<Coord>> wallRegions = GetRegions (1); // 1 = wall
		int wallThresholdSize = 30; // wall region of less that X tiles is removed // default is 50

		foreach (List<Coord> wallRegion in wallRegions) {
			if (wallRegion.Count < wallThresholdSize) {
				foreach (Coord tile in wallRegion) { //goes through every tile region
					map[tile.tileX,tile.tileY] = 0; //makes little islands of walls into empty tile space 
				}
			}
		}
		
		Vector3 testSpawn = CoordToPosition (mapCentre.tileX, mapCentre.tileY);
		mapCentre = new Coord (width / 2, height / 2);

		List<List<Coord>> roomRegions = GetRegions (0); //Similiar to above method but for rooms 
		int roomThresholdSize = 65; //default is 50, room size //70 is good
		List<Room> survivingRooms = new List<Room> (); //Rooms that pass the culling process of removing inperfect rooms

		foreach (List<Coord> roomRegion in roomRegions) { //info gathered from Rooms
			if (roomRegion.Count < roomThresholdSize) {
				foreach (Coord tile in roomRegion) {
					map[tile.tileX,tile.tileY] = 1;
				//openTileCoords.Add(new Coord (tile.tileX,tile.tileY)); // TEST STUFF HERE

				//Instantiate (playerSpawn,,Quaternion.identity);
					//openTileCoords.Add(tile);
				}
			}
			else {
				survivingRooms.Add(new Room(roomRegion, map));
			}
		}

		/*foreach (Room r in survivingRooms) {
			print (r.roomSize);// gives list of rooms sizes in descending order // for testing
		}*/
	
		survivingRooms [0].isMainRoom = true; // possible spawn point, maybe not   //
		survivingRooms [0].isAccessibleFromMainRoom = true;

		ConnectClosestRooms (survivingRooms); //See Method

	/*foreach (List<Coord> roomRegion in roomRegions) { //info gathered from Rooms
		foreach (Coord tile in roomRegion) {
					//Debug.Log ("a");
			openTileCoords.Add(tile);
				}
			}*/
	}
		

	void ConnectClosestRooms(List<Room> allRooms, bool forceAccessibilityFromMainRoom = false) {
		//Responsible for connecting rooms
		//Compare Room A with every other room to find closest (edge tiles of other room)
		List<Room> roomListA = new List<Room> ();
		List<Room> roomListB = new List<Room> ();

		if (forceAccessibilityFromMainRoom) {	
			
			foreach (Room room in allRooms) {
				if (room.isAccessibleFromMainRoom) {
					roomListB.Add (room);
				} else {
					roomListA.Add (room);
				}
			}
		} else {
			roomListA = allRooms;
			roomListB = allRooms;
		}

		int bestDistance = 0; //best distance between rooms
	    Coord bestTileA = new Coord (); //Most suitable distances between edge tiles
		Coord bestTileB = new Coord ();
		Room bestRoomA = new Room ();//Where the above tiles belong
		Room bestRoomB = new Room ();
		bool possibleConnectionFound = false; //if connections are found between rooms
	
		foreach (Room roomA in roomListA) {
			if (!forceAccessibilityFromMainRoom) {
				possibleConnectionFound = false; //reset with every loop 
				if (roomA.connectedRooms.Count > 0) {
					continue; //continue to skip to next room 
				}
			}

			foreach (Room roomB in roomListB) {
				if (roomA == roomB || roomA.IsConnected(roomB)) { //prevents a comparison of the same room A = B, moves to next object 
					continue; //continue to skip to next room
				}
				//calculates edge tiles distance with rooms
				for (int tileIndexA = 0; tileIndexA < roomA.edgeTiles.Count; tileIndexA ++) {
					for (int tileIndexB = 0; tileIndexB < roomB.edgeTiles.Count; tileIndexB ++) {
						Coord tileA = roomA.edgeTiles[tileIndexA];
						Coord tileB = roomB.edgeTiles[tileIndexB];
						// Using distance formula to compare distances between rooms
						int distanceBetweenRooms = (int)(Mathf.Pow/*power*/ (tileA.tileX-tileB.tileX,2) + Mathf.Pow (tileA.tileY-tileB.tileY,2)); //returns float, cast to integer

						if (distanceBetweenRooms < bestDistance || !possibleConnectionFound) { // || = or // if the correct distance is found 
							bestDistance = distanceBetweenRooms;
							possibleConnectionFound = true;
							bestTileA = tileA;
							bestTileB = tileB;
							bestRoomA = roomA;
							bestRoomB = roomB; //for empty room constructor 
						}
					}
				}
			}
			if (possibleConnectionFound && !forceAccessibilityFromMainRoom) { //only incur when not forcing 
				CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
			
			}
		}

		if (possibleConnectionFound && forceAccessibilityFromMainRoom) { // is forcing then recall method // see diagram
			CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
			ConnectClosestRooms(allRooms, true);
		}

		if (!forceAccessibilityFromMainRoom) { // if not calls method again to force isolated rooms to be connected to main room 
			ConnectClosestRooms(allRooms, true);
		}
	}

	void CreatePassage(Room roomA, Room roomB, Coord tileA, Coord tileB) { //needs the 2 rooms that are being connected in order to create passage between them 
		Room.ConnectRooms (roomA, roomB);
		//Debug.DrawLine (CoordToWorldPoint (tileA), CoordToWorldPoint (tileB), Color.green, 100); //Unity Debug lines for testing 

		List<Coord> line = GetLine (tileA, tileB); //list of Coordinates for the line 
		foreach (Coord c in line) {			// HAVE A LOOK AT THIS FUNCTION FOR LATER REFERENCE FOR MAKING STUFF HAPPEN WITH COORDS
			DrawCircle (c, 8); //Width of these passages 
		}
	}

	void DrawCircle (Coord c, int r) //radius for the passage to be created
	{
		for (int x = -r; x <= r; x++) {
			for (int y = -r; y <= r; y++) {
				if (x * x + y * y <= r * r) {
					int drawX = c.tileX + x;
					int drawY = c.tileY + y;
					if (IsInMapRange (drawX, drawY)) {
						map [drawX, drawY] = 0; //turns tiles to empty spaces 
					}
				}
			}
		}
		
	}

	List<Coord> GetLine(Coord from, Coord to) //Method for creating lines for creating passage ways
	{
		List<Coord> line = new List <Coord> ();
		int x = from.tileX;
		int y = from.tileY;

		int dx = to.tileX = from.tileX;
		int dy = to.tileY - from.tileY;

		bool inverted = false; //Incase Y greater than X

		int step = Math.Sign (dx); //value for incrementing X, returns float 
		int gradientStep = Math.Sign (dy); //Value for Y

		int longest = Mathf.Abs (dx); //absolute value for dx
		int shortest = Mathf.Abs (dy); 

		if (longest < shortest) 
		{
			inverted = true;
			longest = Mathf.Abs (dy);
			shortest = Mathf.Abs (dx);

			step = Math.Sign (dy);
			gradientStep = Math.Sign (dx);

		}

		int gradientAccumulation = longest / 2; //incase for dx or dy
		for (int i = 0; i < longest; i++) {
			line.Add (new Coord (x, y));

			if (inverted) {
				y += step;
			} else {
				x += step;
			}
			gradientAccumulation += shortest;
			if (gradientAccumulation >= longest) {
				if (inverted) {
					x += gradientStep;
				} else {
					y += gradientStep;
				}
				gradientAccumulation -= longest;
					
			}
		}
		return line; //returns line 
	}

	Vector3 CoordToWorldPoint(Coord tile) { //coversion of tiles to world Coord
		return new Vector3 (-width / 2 + .5f + tile.tileX, 2, -height / 2 + .5f + tile.tileY);
	}

	Vector3 CoordToPosition(int x, int y) {
		return new Vector3 (-mapSize.x / 2 + 0.5f + x, 0, -mapSize.y / 2 + 0.5f + y);

	}
// .....................................................
	/*public Coords GetRandomCoords() {

		Coords randomCoords = shuffledTileCoords.Dequeue ();

		shuffledTileCoords.Enqueue (randomCoords);
		return randomCoords;
	}

	Vector3 CoordsToPosition(int x, int y) {
		return new Vector3 (-mapSize.x / 2 + 0.5f + x, 0, -mapSize.y / 2 + 0.5f + y);

	}

	public struct Coords {
		public int x;
		public int y;

		public Coords(int _x, int _y) {

			x = _x;
			y = _y;
		}
	}*/
	//.....................................................

	List<List<Coord>> GetRegions(int tileType) { //takes in integer tile type, creates tile regions
		List<List<Coord>> regions = new List<List<Coord>> ();
		int[,] mapFlags = new int[width,height];

		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				if (mapFlags[x,y] == 0 && map[x,y] == tileType) {
					List<Coord> newRegion = GetRegionTiles(x,y); //new list of Coord 
					regions.Add(newRegion);//List of regions

					foreach (Coord tile in newRegion) {
						mapFlags[tile.tileX, tile.tileY] = 1; //marks regions has already looked at in list
					}
				}
			}
		}

		return regions; //returns list of regions
	}

	List<Coord> GetRegionTiles(int startX, int startY) {
		//List to store tiles in
		List<Coord> tiles = new List<Coord> ();
		int[,] mapFlags = new int[width,height]; //2d array of map, rather than 1 and 0s
		int tileType = map [startX, startY];// sets tile type rather than 1 and 0 

		Queue<Coord> queue = new Queue<Coord> ();//Queue type to store Coordinates
		queue.Enqueue (new Coord (startX, startY));//Add start Coordinates
		mapFlags [startX, startY] = 1; //set mapflags 

		while (queue.Count > 0) { //while stuff is left in queue get first tile
			Coord tile = queue.Dequeue(); //remove item in queue
			tiles.Add(tile);

			for (int x = tile.tileX - 1; x <= tile.tileX + 1; x++) { //looks at adjacent tiles from starting tile 
				for (int y = tile.tileY - 1; y <= tile.tileY + 1; y++) {
					if (IsInMapRange(x,y) && (y == tile.tileY || x == tile.tileX)) { //map range bool method
						if (mapFlags[x,y] == 0 && map[x,y] == tileType) {
							mapFlags[x,y] = 1;
							queue.Enqueue(new Coord(x,y));
						}
					}
				}
			}
		}

		return tiles; //returns a list of Coordinates, creates regions
	}

	bool IsInMapRange(int x, int y) { //returns bool for map range
		return x >= 0 && x < width && y >= 0 && y < height;
	}

	void getOpenMap()
		{
	
		}


	void RandomFillMap() {
		if (useRandomSeed) {
			seed = Time.time.ToString();
		seedx = (int) Time.time;

		}

	System.Random pseudoRandom = new System.Random(seed.GetHashCode()); //random number generator

		// loop for each tile on map
		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				if (x == 0 || x == width-1 || y == 0 || y == height -1) {   //Generate walls around the edge of the map  || = or
					map[x,y] = 1; //Will be a wall
				}
				else {
					map[x,y] = (pseudoRandom.Next(0,100) < randomFillPercent)? 1: 0; //min and max value, inbetween, add wall or blank tile //? is if else
				}
			}
		}
	} // LOOK AT LOGIC OF THIS, maybe way to call this and add a extra for loop to get every tile that = 1, then put this into a list of Coords, maybe convert as well before or after
		// then random this up then hopefully it might give open tile Coords, then a distance algorithm will be needed
			//Also consider process in tile map script where the map is a vector 2, maybe do a copy and convert of the current int array

	void SmoothMap() {
		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				int neighbourWallTiles = GetSurroundingWallCount(x,y); //number of neighbouring tiles that are walls from Surrounding Wall count method

				if (neighbourWallTiles > 4) 
					map[x,y] = 1; //makes tiles surrounded by walls into a wall
			
				else if (neighbourWallTiles < 4)
					map[x,y] = 0; // else it remains empty
			//List<Coord> allOpenCoords = new List<Coord>(allTileCoords);
				
			}
		}
	}

	int GetSurroundingWallCount(int gridX, int gridY) { //get a tiles neighbouring tiles and their states // || = or
	int wallCount = 0;

		for (int neighbourX = gridX - 1; neighbourX <= gridX + 1; neighbourX ++) {
			for (int neighbourY = gridY - 1; neighbourY <= gridY + 1; neighbourY ++) {
				if (IsInMapRange(neighbourX,neighbourY)) {
					if (neighbourX != gridX || neighbourY != gridY) {
						wallCount += map[neighbourX,neighbourY];
					}
				}
				else {
					wallCount ++;
				}
			}
		}

		return wallCount;

	}

	public struct Coord { //Coord system for tiles 
		public int tileX;
		public int tileY;

		public Coord(int x, int y) {
			tileX = x;
			tileY = y;
		}
	}

	class Room : IComparable<Room> { // stores all info for rooms and sorts
		public List<Coord> tiles; //stores tiles of the room
		public List<Coord> edgeTiles; // tiles that are on the edges, calculated for finding distances between rooms 
		public List<Room> connectedRooms; //rooms that share a passage

		//public List<Coord>openTileCoords;

		public int roomSize; //number of tiles in a room, largest size room will be primary room
		public bool isAccessibleFromMainRoom; 
		public bool isMainRoom;

		public Room() { // empty contructor
		}

		public Room(List<Coord> roomTiles, int[,] map) { 
			tiles = roomTiles;
			roomSize = tiles.Count; //number of tiles in tile list 
			connectedRooms = new List<Room>();

			edgeTiles = new List<Coord>(); //empty list of Coord
		//openTileCoords = new List<Coord>();
			foreach (Coord tile in tiles) { // look at tile neighbours to find the edge tiles
				for (int x = tile.tileX-1; x <= tile.tileX+1; x++) {
					for (int y = tile.tileY-1; y <= tile.tileY+1; y++) {
						if (x == tile.tileX || y == tile.tileY) {
							if (map[x,y] == 1) {
								edgeTiles.Add(tile); //add to edge tile list 
								//openTileCoords.Add(tile);
							}
						}
					}
				}
			}
		}

		public void SetAccessibleFromMainRoom() { // when connected sets other room connected to main room to accessible 
			if (!isAccessibleFromMainRoom) {
				isAccessibleFromMainRoom = true;
				foreach (Room connectedRoom in connectedRooms) {
					connectedRoom.SetAccessibleFromMainRoom();
				}
			}
		}

		public static void ConnectRooms(Room roomA, Room roomB) { //takes in 2 rooms A and B, adds them to each others list of connectivity
			if (roomA.isAccessibleFromMainRoom) { //if room A is accessible
				roomB.SetAccessibleFromMainRoom ();
			} else if (roomB.isAccessibleFromMainRoom) {
				roomA.SetAccessibleFromMainRoom();
			}
			roomA.connectedRooms.Add (roomB);
			roomB.connectedRooms.Add (roomA);
		}

		public bool IsConnected(Room otherRoom) { // returns if connected rooms contain the other
			return connectedRooms.Contains(otherRoom);
		}

		public int CompareTo(Room otherRoom) { // compare room sizes in order to find largest to smallest
			return otherRoom.roomSize.CompareTo (roomSize);
		}
	}



}