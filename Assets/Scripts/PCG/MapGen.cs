using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine.UI;

public class MapGen : MonoBehaviour {

	public int width; //width of the generated map
	public int height; //height of the generated map

	public GameObject playerSpawn;// Player Spawn location, may be better with transform for location
	public GameObject player;
	public GameObject endPoint; // End Point location as oppose to player spawn location for level ending and generation of new one

	public float levelFinished; //Counter for number of levels finished
	public bool levelComplete; // Once completed a new level will be generated
	public bool gameOver; // Will be called true when suffcient amount of levels have been completed and test is over, data will be exported to be written to file 

	public string seed; //Random seed generated by system
	public bool useRandomSeed; //Use or not use the randomseed

	[Range(0,100)] //can only be 1 to 100
	public int randomFillPercent;

	int[,] map; //2D array of ints

	public MeshGen meshGenerator; //Mesh Generator class

	//public Vector3 spawnValues;
	public Vector2 mapSize;

	Coord mapEdge; //Coordinates for the map edge
	Coord mapEdgeExit; // Duplicate coordinates
	Coord mapCentre;

	Transform[,] tileMap; //2D array for traking the tile map

	public static bool explorer; //explorer Taxonomy
	public static bool killer; //Killer Taxonomy
	public static bool acheiver; //Acheiver Taxonomy
	public bool isExplorer; //For calculating explorer type
	public bool isKiller; //For calculating killer type
	public bool isAcheiver; //For calculating acheiver type

	public Transform targetPrefab; //transform type for targets
	public Transform playerSpawnPoint;

	List<Coord>allTileCoords; // List of all tile coordinates
	Queue<Coord> shuffledTileCoords; // Queue type for shuffling coords from the Utility script
	//Queue<Coord> shuffledOpenTileCoords;

	 public int seedx = 10; //secondary seed

	public static int endLevelValue;

	public static int Explored; //tracking the amount of map explored
	public static int Accurate; //tracking the amount of enemies hit on target
	public static int defeated; //amount of enemies defeated
	public static float timeSaved; //timestamp of time taken
	public static int totalEnemies; //Total number of enemies that were alive

	public int levelTrack;

	public int exploreValue; 
	public int accurateValue;
	public int numberEnemies; 
	public GameObject[] enemies; //Array of enemies to track targets

	public float TimeInSeconds; // float for time 

	public dataScript saveData; //reference to the script for collecting and exporting test data

	void Start() {
		GenerateMap(); //Method calling the generator
		//spawner();
		Explored = 0;
		TimeInSeconds = 0; 
		isExplorer = false;
		isKiller = false;
		isAcheiver = false;
		levelTrack = 0;
	}

	void Update() {
		
		decideTax();

		/*if (Input.GetKey ("space")) {
			GenerateMap(); //use mouse click to generate new map with each click
			meshGenerator.removeWallMesh();
			clearTargets ();
			clearSpawner ();
			//levelTrack = levelTrack + 1;

			//Destroy old mesh and walls and make new mesh 
		}*/

		if (Input.GetKey ("left")) {
			saveData.save ();
		}
		if (Input.GetKey ("up")) {
			saveData.save2 ();
		}
		if (Input.GetKey ("right")) {
			saveData.save3 ();
		}

		if (Input.GetKey ("o")) {
			overideSpawn ();
		}
			
		levelTrack = endLevelValue;

		/*if (levelTrack == 1) { //Problem : data is saved just as collision of player and end point occurs, needs to be just before the level is regenerated
			saveData.save ();
		}

		if (levelTrack == 2) 
		{
			saveData.save2 ();
		}

		if (levelTrack == 3) 
		{
			saveData.save3 ();
			Debug.Log ("Test Concluded, load end scene and finish data collection");
		}*/

		enemies = GameObject.FindGameObjectsWithTag ("Enemy");
		playerSpawn = GameObject.FindGameObjectWithTag ("Spawn");

		for (int i = 0; i < enemies.Length; i++)
		{
			numberEnemies = i;
			totalEnemies = numberEnemies;
		}	

		TimeInSeconds += 1*Time.deltaTime;

		exploreValue = Explored;
		accurateValue = Accurate;
		timeSaved = TimeInSeconds;
		explorer = isExplorer;


	}

	/*IEnumerator Dead() {
		Debug.Log ("dead");
		renderer.enabled = false;
		yield return new WaitForSeconds(5);
		Debug.Log ("respawn");
		renderer.enabled = true;
	}*/

	void overideSpawn()
	{
		GenerateMap(); //use mouse click to generate new map with each click
		meshGenerator.removeWallMesh();
		clearTargets ();
		clearSpawner ();
		//clearPlayer ();
		//StartCoroutine (Dead ());
		
	}
	public void regenLevel()
	{
		GenerateMap(); //use mouse click to generate new map with each click
		meshGenerator.removeWallMesh();
		clearTargets ();
		clearSpawner ();
		clearValues ();
		Debug.Log("RESET COMPLETE");

	}
	void clearSpawner()
	{
		Destroy (playerSpawn);
		//Destroy (endPoint);
	}

	void clearTargets()
	{
		foreach (GameObject x in enemies)
		{
			Destroy (x);
		}

	}

	void clearValues()
	{
		Explored = 0;
		Accurate = 0;
		defeated = 0;
		timeSaved = 0;
		totalEnemies = 0;
		TimeInSeconds = 0;
		
	}

	void decideTax()
	{
		if (exploreValue >= 10 && accurateValue < 5) 
		{
			isExplorer = true;
		}
		else
		{
			isExplorer = false;	
		}

		if (accurateValue > 19) 
		{
			isKiller = true;
		}
	}
		
	void spawner ()
	{
		System.Random pseudoRandom = new System.Random(seedx.GetHashCode()); //random number generator

		allTileCoords = new List<Coord> ();

		for (int x = 0; x < mapSize.x; x++) {
			for (int y = 0; y < mapSize.y; y++) {
				allTileCoords.Add (new Coord (x, y));
			}
		}

		shuffledTileCoords = new Queue<Coord> (Utility.ShuffleArray (allTileCoords.ToArray (), seedx));

		/*for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				map [x, y] == 1 ? isWall = true: isWall = false; 
			}
		}*/
				
		/*for (int x = 0; x < mapSize.x; x++) {
			for (int y = 0; y < mapSize.y; y++) {

				//int spawnPoints = 1;
				//for (int i = 0; i < spawnPoints; i++) {
					Vector3 tilePosition = CoordToPosition (x, y);
					Transform spawnPoint = Instantiate (spawnPrefab, tilePosition, Quaternion.identity)as Transform;
				//}
			}
		}*/

	//Targets
		int spawnPoints = 35;
		for (int i = 0; i < spawnPoints; i++) {
			Coord randomCoord = GetRandomCoord ();
			Vector3 spawnPosition = CoordToPosition (randomCoord.tileX, randomCoord.tileY);
		Transform spawnPoint = Instantiate (targetPrefab, spawnPosition + Vector3.up, Quaternion.Euler(0,0,90)) as Transform;
		}

	//Player Start 	

		if (levelTrack == 0) {
			mapEdge = new Coord (width - 10, height - 190);
			Vector3 edgeSpawn = CoordToPosition (mapEdge.tileX, mapEdge.tileY);
			GameObject spawner = Instantiate (playerSpawn, edgeSpawn + Vector3.up * 0.5f, Quaternion.identity) as GameObject;



			//End Point
			mapEdgeExit = new Coord (width - 140, height - 10);
			Vector3 edgeSpawnExit = CoordToPosition (mapEdgeExit.tileX, mapEdgeExit.tileY);
			GameObject exitPoint = Instantiate (endPoint, edgeSpawnExit + Vector3.up * 0.5f, Quaternion.Euler (270, 0, 90)) as GameObject;

			//Player
			/*mapCentre = new Coord (width - 10, height - 190);
			Vector3 centreSpawn = CoordToPosition (mapEdge.tileX, mapEdge.tileY);
			Instantiate (player, centreSpawn + Vector3.up * 1.0f, Quaternion.identity);*/
		}

		if (levelTrack >= 1)
	{
		}
	}

	public Coord GetRandomCoord() {

		Coord randomCoord = shuffledTileCoords.Dequeue ();

		shuffledTileCoords.Enqueue (randomCoord);

		return randomCoord;
	}



	void GenerateMap() {			//method for generating map
	
		map = new int[width,height];
		
		/*mapEdge = new Coord (width / 2, height / 2);
		Vector3 centreSpawn = CoordToPosition (mapEdge.tileX, mapEdge.tileY);
		Transform spawner = Instantiate (spawnPrefab, centreSpawn + Vector3.up * 0.5f, Quaternion.identity) as Transform;*/
		spawner ();
		RandomFillMap();

		for (int i = 0; i < 5; i ++) { //increments of smooth map
			SmoothMap();
		}

		ProcessMap (); //checks tile regions for small isolated islands of walls 

		int borderSize = 2; // size of the border around generated map
		int[,] borderedMap = new int[width + borderSize * 2,height + borderSize * 2]; // 2d int array for the border of the map for both sides (L+R)

		for (int x = 0; x < borderedMap.GetLength(0); x ++) { //make bordered map same size but only slightly larger
			for (int y = 0; y < borderedMap.GetLength(1); y ++) {
				if (x >= borderSize && x < width + borderSize && y >= borderSize && y < height + borderSize) { //&& and // 
					borderedMap[x,y] = map[x-borderSize,y-borderSize];// set bordered map
				}
				else {
					borderedMap[x,y] =1; //if inside bordered map
				}
			}
		}

		MeshGen meshGen = GetComponent<MeshGen>(); //Generate mesh from Mesh Gen
		meshGen.GenerateMesh(borderedMap, 1);

	}

	void ProcessMap() { //getting list of list of Coord of wall regions. 
		List<List<Coord>> wallRegions = GetRegions (1); // 1 = wall
		int wallThresholdSize = 30; // wall region of less that X tiles is removed // default is 50

		foreach (List<Coord> wallRegion in wallRegions) {
			if (wallRegion.Count < wallThresholdSize) {
				foreach (Coord tile in wallRegion) { //goes through every tile region
					map[tile.tileX,tile.tileY] = 0; //makes little islands of walls into empty tile space 
				}
			}
		}

		List<List<Coord>> roomRegions = GetRegions (0); //Similiar to above method but for rooms 
		int roomThresholdSize = 65; //default is 50, room size //70 is good
		List<Room> survivingRooms = new List<Room> (); //Rooms that pass the culling process of removing inperfect rooms

		foreach (List<Coord> roomRegion in roomRegions) { //info gathered from Rooms
			if (roomRegion.Count < roomThresholdSize) {
				foreach (Coord tile in roomRegion) {
					map[tile.tileX,tile.tileY] = 1;
				}
			}
			else {
				survivingRooms.Add(new Room(roomRegion, map));
			}
		}
		survivingRooms.Sort ();
		/*foreach (Room r in survivingRooms) {
			print (r.roomSize);// gives list of rooms sizes in descending order // for testing
		}*/
		survivingRooms [0].isMainRoom = true; // possible spawn point, maybe not   //
		survivingRooms [0].isAccessibleFromMainRoom = true;

		ConnectClosestRooms (survivingRooms); //See Method

		//Vector3 spawnPosition = CoordToPosition ();
		//Transform newSpawn = Instantiate (spawnPrefab, spawnPosition + Vector3.up * .5f, Quaternion.identity) as Transform;

	}
		

	void ConnectClosestRooms(List<Room> allRooms, bool forceAccessibilityFromMainRoom = false) {
		//Responsible for connecting rooms
		//Compare Room A with every other room to find closest (edge tiles of other room)
		List<Room> roomListA = new List<Room> ();
		List<Room> roomListB = new List<Room> ();

		if (forceAccessibilityFromMainRoom) {	
			
			foreach (Room room in allRooms) {
				if (room.isAccessibleFromMainRoom) {
					roomListB.Add (room);
				} else {
					roomListA.Add (room);
				}
			}
		} else {
			roomListA = allRooms;
			roomListB = allRooms;
		}

		int bestDistance = 0; //best distance between rooms
	    Coord bestTileA = new Coord (); //Most suitable distances between edge tiles
		Coord bestTileB = new Coord ();
		Room bestRoomA = new Room ();//Where the above tiles belong
		Room bestRoomB = new Room ();
		bool possibleConnectionFound = false; //if connections are found between rooms
	
		foreach (Room roomA in roomListA) {
			if (!forceAccessibilityFromMainRoom) {
				possibleConnectionFound = false; //reset with every loop 
				if (roomA.connectedRooms.Count > 0) {
					continue; //continue to skip to next room 
				}
			}

			foreach (Room roomB in roomListB) {
				if (roomA == roomB || roomA.IsConnected(roomB)) { //prevents a comparison of the same room A = B, moves to next object 
					continue; //continue to skip to next room
				}
				//calculates edge tiles distance with rooms
				for (int tileIndexA = 0; tileIndexA < roomA.edgeTiles.Count; tileIndexA ++) {
					for (int tileIndexB = 0; tileIndexB < roomB.edgeTiles.Count; tileIndexB ++) {
						Coord tileA = roomA.edgeTiles[tileIndexA];
						Coord tileB = roomB.edgeTiles[tileIndexB];
						// Using distance formula to compare distances between rooms
						int distanceBetweenRooms = (int)(Mathf.Pow/*power*/ (tileA.tileX-tileB.tileX,2) + Mathf.Pow (tileA.tileY-tileB.tileY,2)); //returns float, cast to integer

						if (distanceBetweenRooms < bestDistance || !possibleConnectionFound) { // || = or // if the correct distance is found 
							bestDistance = distanceBetweenRooms;
							possibleConnectionFound = true;
							bestTileA = tileA;
							bestTileB = tileB;
							bestRoomA = roomA;
							bestRoomB = roomB; //for empty room constructor 
						}
					}
				}
			}
			if (possibleConnectionFound && !forceAccessibilityFromMainRoom) { //only incur when not forcing 
				CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
			
			}
		}

		if (possibleConnectionFound && forceAccessibilityFromMainRoom) { // is forcing then recall method // see diagram
			CreatePassage(bestRoomA, bestRoomB, bestTileA, bestTileB);
			ConnectClosestRooms(allRooms, true);
		}

		if (!forceAccessibilityFromMainRoom) { // if not calls method again to force isolated rooms to be connected to main room 
			ConnectClosestRooms(allRooms, true);
		}
	}

	void CreatePassage(Room roomA, Room roomB, Coord tileA, Coord tileB) { //needs the 2 rooms that are being connected in order to create passage between them 
		Room.ConnectRooms (roomA, roomB);
		//Debug.DrawLine (CoordToWorldPoint (tileA), CoordToWorldPoint (tileB), Color.green, 100); //Unity Debug lines for testing 

		List<Coord> line = GetLine (tileA, tileB); //list of Coordinates for the line 
		foreach (Coord c in line) {
			DrawCircle (c, 8); //Width of these passages 
		}
	}

	void DrawCircle (Coord c, int r) //radius for the passage to be created
	{
		for (int x = -r; x <= r; x++) {
			for (int y = -r; y <= r; y++) {
				if (x * x + y * y <= r * r) {
					int drawX = c.tileX + x;
					int drawY = c.tileY + y;
					if (IsInMapRange (drawX, drawY)) {
						map [drawX, drawY] = 0; //turns tiles to empty spaces 
					}
				}
			}
		}
		
	}

	List<Coord> GetLine(Coord from, Coord to) //Method for creating lines for creating passage ways
	{
		List<Coord> line = new List <Coord> ();
		int x = from.tileX;
		int y = from.tileY;

		int dx = to.tileX = from.tileX;
		int dy = to.tileY - from.tileY;

		bool inverted = false; //Incase Y greater than X

		int step = Math.Sign (dx); //value for incrementing X, returns float 
		int gradientStep = Math.Sign (dy); //Value for Y

		int longest = Mathf.Abs (dx); //absolute value for dx
		int shortest = Mathf.Abs (dy); 

		if (longest < shortest) 
		{
			inverted = true;
			longest = Mathf.Abs (dy);
			shortest = Mathf.Abs (dx);

			step = Math.Sign (dy);
			gradientStep = Math.Sign (dx);

		}

		int gradientAccumulation = longest / 2; //incase for dx or dy
		for (int i = 0; i < longest; i++) {
			line.Add (new Coord (x, y));

			if (inverted) {
				y += step;
			} else {
				x += step;
			}
			gradientAccumulation += shortest;
			if (gradientAccumulation >= longest) {
				if (inverted) {
					x += gradientStep;
				} else {
					y += gradientStep;
				}
				gradientAccumulation -= longest;
					
			}
		}
		return line; //returns line 
	}

	Vector3 CoordToWorldPoint(Coord tile) { //coversion of tiles to world Coord
		return new Vector3 (-width / 2 + .5f + tile.tileX, 2, -height / 2 + .5f + tile.tileY);
	}

	Vector3 CoordToPosition(int x, int y) {
		return new Vector3 (-mapSize.x / 2 + 0.5f + x, 0, -mapSize.y / 2 + 0.5f + y);

	}
// .....................................................
	/*public Coords GetRandomCoords() {

		Coords randomCoords = shuffledTileCoords.Dequeue ();

		shuffledTileCoords.Enqueue (randomCoords);
		return randomCoords;
	}

	Vector3 CoordsToPosition(int x, int y) {
		return new Vector3 (-mapSize.x / 2 + 0.5f + x, 0, -mapSize.y / 2 + 0.5f + y);

	}

	public struct Coords {
		public int x;
		public int y;

		public Coords(int _x, int _y) {

			x = _x;
			y = _y;
		}
	}*/
	//.....................................................

	List<List<Coord>> GetRegions(int tileType) { //takes in integer tile type, creates tile regions
		List<List<Coord>> regions = new List<List<Coord>> ();
		int[,] mapFlags = new int[width,height];

		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				if (mapFlags[x,y] == 0 && map[x,y] == tileType) {
					List<Coord> newRegion = GetRegionTiles(x,y); //new list of Coord 
					regions.Add(newRegion);//List of regions

					foreach (Coord tile in newRegion) {
						mapFlags[tile.tileX, tile.tileY] = 1; //marks regions has already looked at in list
					}
				}
			}
		}

		return regions; //returns list of regions
	}

	List<Coord> GetRegionTiles(int startX, int startY) {
		//List to store tiles in
		List<Coord> tiles = new List<Coord> ();
		int[,] mapFlags = new int[width,height]; //2d array of map, rather than 1 and 0s
		int tileType = map [startX, startY];// sets tile type rather than 1 and 0 

		Queue<Coord> queue = new Queue<Coord> ();//Queue type to store Coordinates
		queue.Enqueue (new Coord (startX, startY));//Add start Coordinates
		mapFlags [startX, startY] = 1; //set mapflags 

		while (queue.Count > 0) { //while stuff is left in queue get first tile
			Coord tile = queue.Dequeue(); //remove item in queue
			tiles.Add(tile);

			for (int x = tile.tileX - 1; x <= tile.tileX + 1; x++) { //looks at adjacent tiles from starting tile 
				for (int y = tile.tileY - 1; y <= tile.tileY + 1; y++) {
					if (IsInMapRange(x,y) && (y == tile.tileY || x == tile.tileX)) { //map range bool method
						if (mapFlags[x,y] == 0 && map[x,y] == tileType) {
							mapFlags[x,y] = 1;
							queue.Enqueue(new Coord(x,y));
						}
					}
				}
			}
		}

		return tiles; //returns a list of Coordinates, creates regions
	}

	bool IsInMapRange(int x, int y) { //returns bool for map range
		return x >= 0 && x < width && y >= 0 && y < height;
	}


	void RandomFillMap() {
		if (useRandomSeed) {
			seed = Time.time.ToString();
		seedx = (int) Time.time;

		}

	System.Random pseudoRandom = new System.Random(seed.GetHashCode()); //random number generator

		// loop for each tile on map
		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				if (x == 0 || x == width-1 || y == 0 || y == height -1) {   //Generate walls around the edge of the map  || = or
					map[x,y] = 1; //Will be a wall
				}
				else {
					map[x,y] = (pseudoRandom.Next(0,100) < randomFillPercent)? 1: 0; //min and max value, inbetween, add wall or blank tile //? is if else
				}
			}
		}
	}

	void SmoothMap() {
		for (int x = 0; x < width; x ++) {
			for (int y = 0; y < height; y ++) {
				int neighbourWallTiles = GetSurroundingWallCount(x,y); //number of neighbouring tiles that are walls from Surrounding Wall count method

				if (neighbourWallTiles > 4) 
					map[x,y] = 1; //makes tiles surrounded by walls into a wall
			
				else if (neighbourWallTiles < 4)
					map[x,y] = 0; // else it remains empty
			//List<Coord> allOpenCoords = new List<Coord>(allTileCoords);

			}
		}
	}

	int GetSurroundingWallCount(int gridX, int gridY) { //get a tiles neighbouring tiles and their states // || = or
	int wallCount = 0;

		for (int neighbourX = gridX - 1; neighbourX <= gridX + 1; neighbourX ++) {
			for (int neighbourY = gridY - 1; neighbourY <= gridY + 1; neighbourY ++) {
				if (IsInMapRange(neighbourX,neighbourY)) {
					if (neighbourX != gridX || neighbourY != gridY) {
						wallCount += map[neighbourX,neighbourY];
					}
				}
				else {
					wallCount ++;
				}
			}
		}

		return wallCount;

	}

	public struct Coord { //Coord system for tiles 
		public int tileX;
		public int tileY;

		public Coord(int x, int y) {
			tileX = x;
			tileY = y;

			//retrieve tileX,tileY,0 for posistion. Use Coord for locations, figure out Vector 3

		}
	}

	class Room : IComparable<Room> { // stores all info for rooms and sorts
		public List<Coord> tiles; //stores tiles of the room
		public List<Coord> edgeTiles; // tiles that are on the edges, calculated for finding distances between rooms 
		public List<Room> connectedRooms; //rooms that share a passage
		public int roomSize; //number of tiles in a room, largest size room will be primary room
		public bool isAccessibleFromMainRoom; 
		public bool isMainRoom;

		public Room() { // empty contructor
		}

		public Room(List<Coord> roomTiles, int[,] map) { 
			tiles = roomTiles;
			roomSize = tiles.Count; //number of tiles in tile list 
			connectedRooms = new List<Room>();

			edgeTiles = new List<Coord>(); //empty list of Coord
			foreach (Coord tile in tiles) { // look at tile neighbours to find the edge tiles
				for (int x = tile.tileX-1; x <= tile.tileX+1; x++) {
					for (int y = tile.tileY-1; y <= tile.tileY+1; y++) {
						if (x == tile.tileX || y == tile.tileY) {
							if (map[x,y] == 1) {
								edgeTiles.Add(tile); //add to edge tile list 
							}
						}
					}
				}
			}
		}

		public void SetAccessibleFromMainRoom() { // when connected sets other room connected to main room to accessible 
			if (!isAccessibleFromMainRoom) {
				isAccessibleFromMainRoom = true;
				foreach (Room connectedRoom in connectedRooms) {
					connectedRoom.SetAccessibleFromMainRoom();
				}
			}
		}

		public static void ConnectRooms(Room roomA, Room roomB) { //takes in 2 rooms A and B, adds them to each others list of connectivity
			if (roomA.isAccessibleFromMainRoom) { //if room A is accessible
				roomB.SetAccessibleFromMainRoom ();
			} else if (roomB.isAccessibleFromMainRoom) {
				roomA.SetAccessibleFromMainRoom();
			}
			roomA.connectedRooms.Add (roomB);
			roomB.connectedRooms.Add (roomA);
		}

		public bool IsConnected(Room otherRoom) { // returns if connected rooms contain the other
			return connectedRooms.Contains(otherRoom);
		}

		public int CompareTo(Room otherRoom) { // compare room sizes in order to find largest to smallest
			return otherRoom.roomSize.CompareTo (roomSize);
		}
	}



}